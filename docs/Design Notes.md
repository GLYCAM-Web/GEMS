This document contains high-level design principles for GEMS.  These are the overall goals that dictate the form of the code.  This document might suggest specific ways that code might realize a design principle, but this is only for illustration.  If a coder finds a better way to realize the specific design principle, it is ok to use that other way.  It is recommended that this better way be used as an illustration if it is not so complex that it distracts from the design information.

## Basic Design Principles

These are the most fundamental design principles, with explanations and examples of realization.

### GEMS is an interface

The primary role of GEMS is to serve as an  interface.  As much as possible, there should be no business logic in GEMS except what is needed for it to perform its function as an interface.  

For example, GEMS will need to know enough about submitting a job to AMBER via Slurm to get that job done, but it shouldn't know very much.  It needs to know where the input files are and where the output should go.  It needs to know certain parameters such as the maximum time that a job should run or the maximum memory to use.  It also needs to know which files AMBER requires and the sorts of files it produces.  But, it should not be concerned (overmuch) with the form or format of the AMBER input files.  It is not terrible that GEMS calls some process to ensure that the files are correct, but it is much, much better if that job can happen outside GEMS - for example, in AMBER.

#### Interface overview

This diagram shows the main stakeholders in GEMS with a focus on their requirements and constraints.  It is described below.

![[ENTERPRISE - GEMS Stakeholders.png]]

On the left-hand side are the various types of GEMS users.  They have the requirement that GEMS must be easy to use.  They all interact with the JSON API (_the API_), which is a contract.  This contract must realize (cause to exist): 

1. The requirement that it be able to represent all the scientific and computing logic needed to provide proper interfaces on either side of GEMS and within GEMS itself.
	- Note that GEMS might need to pass along scientific information (choice of water model, for example) that it does not directly interact with. 
	- In general, GEMS should not be making scientific decisions.  That is the job, mostly, of GMML, and, to a much lesser extent, the website.
1. The constraint that it must be easy to use and understand.
	- Of note: here, _ease of use_ applies to all the stakeholders of GEMS (users, developers, students, etc.)

On the top are the developers.  They are also stakeholders.  For them, GEMS should not be so overly complicated that they cannot easily make additions and changes.

On the right hand side are the applications with which GEMS must interface.  This is where the students become stakeholders.  They should not be required to become Python experts in addition to the very non-trivial scientific methods that they are developing.  They should be able to write simple code to realize the methodologies they develop.  These simple programs need to plug into GEMS with relative ease.

Of course, GEMS must also interface many other codes, programs and APIs.  As with the programs written by students, the interfaces might be anything.

#### The main challenge

The biggest challenge of GEMS is to be able to interface a user-friendly API with entirely arbitrary code on the other side.  It is generally true that the easier you make something for others, the more work that you must do.  GEMS is tasked with making a lot of very difficult interfaces very easy to use.  This is a tall order and is the basis for nearly all design decisions.

The current design can be found in the [[gemsModules/For_Developers]] directory.  See especially [[Workflow Overview]].

#### User-side

On the user-side of the interface, the primary stakeholders are:

- GlycamWeb - the website produced by the Woods group that answers at glycam.org.
- Development variants of GlycamWeb:
	- Developer Environment versions, each separate to the individual developer
	- Live versions that are accessible publicly, e.g., test.glycam.org
- API users: via a Live website
- On the command line:
	- Developers
	- Graduate students
	- Other researchers

#### Application-side

The other side of GEMS interfaces with various applications.  These include:

- GEMS itself.  
	- One part of GEMS might interface another part.  
	- Generally, communication between major parts of GEMS should proceed via the same API used for external interface. 
		- For example, one _Entity_ will generally interact with another _Entity_ via the _Delegator_ using the GEMS API. 
		- Continuing the example, depending on the situation, _Services_ will generally interact with each other via the _Servicer_ within that _Entity_.
- Applications generated by students or by others without deep knowledge of software development.
- Other applications in general, with arbitrary interfaces that are not designed with the intention of being the target of this sort of interface.

### GEMS should be usable by scientists who do molecular modeling 

As much as possible, all parts of the source code should be intelligible to these scientists.  The overall design, choice of variable names, etc., should have the goal of making the code easy for these scientists to understand, use, manipulate and extend.

### Normal interface to GEMS should proceed by a simple, unchanging contract

Here, we're not talking about unit testing or specialized utilities.  This principle is for normal interactions between users and GEMS.

Currently, this is realized as follows:

- Normal interaction with GEMS proceeds only via the Delegator.  
	- Currently, the main entry point for the Delegator is via a script in $GEMSHOME/bin
	- This need not always be so.
- The Delegator receives only a JSON object and responds only with a JSON object.
	- No other command-line input is allowed.
	- No standard error, print statements or other output is allowed.  There can only be a JSON object returned via the standard output.

#### The contract itself should be versioned and only rarely should parts be deprecated

It is unkind to users to constantly change the interface.  Generally, this will cause them to flee.

