#!/usr/bin/env python3
from typing import List, Any 
from os.path import join
from datetime import datetime
from pydantic import BaseModel
from gemsModules.common.loggingConfig import *
from gemsModules.sequence.options_geometry import TheGeometryOptions
import gemsModules.project.projectUtilPydantic as projectUtils
import traceback


if loggers.get(__name__):
    pass
else:
    log = createLogger(__name__)


class TheSystemSolvationOptions(BaseModel):
    solvationStatus: str = Field(
        'Unsolvated',
        description="Unsolvated, To be solvated, Solvated, Not applicable"
    )
    ionStatus: str = Field(
        'No ions',
        description="No ions, Add ions, Contains ions."
    )

class TheBuildOptions(BaseModel):
    """Options for building 3D models"""
    # Generated by evaluation.  Used in builds.
    solvationOptions: TheSystemSolvationOptions = None  # Not yet handled.
    geometryOptions: TheGeometryOptions = None
    mdMinimize: bool = Field(
        True,
        title='Minimize structure using MD',
    )
    numberStructuresHardLimit: int = None  # Website or API calls will enforce 64
    # Set to -1 to get all of them (BEWARE!)

    def __init__(self, **data: Any):
        super().__init__(**data)

    def setGeometryOptions(self, validatedSequence: str):
        log.info("Setting geometryOptions in BuildOptions")
        log.debug("validatedSequence: " + validatedSequence)
        self.geometryOptions = TheGeometryOptions()
        self.geometryOptions.setLinkageRotamerInfo(validatedSequence)

    def getRotamerData(self):
        log.info("buildOptions.getRotamerDataOut was called")
        if self.geometryOptions is None:
            return None
        else:
            return self.geometryOptions.getRotamerData()

    def createRotamerData(self):
        log.info("Build Options.createRotamerDataOut was called")
        if self.geometryOptions is None:
            self.geometryOptions = TheGeometryOptions()
        self.geometryOptions.createRotamerData()


class Single3DStructureBuildDetails(BaseModel):
    ##################################
    # This class was built by merging two older classes.  Therefore, some names
    # might appear to be duplicates.  They might even be duplicates.  There
    # is no time now for this sort of cleaning now.  Please feel free to do so.
    ##################################
    # The timestamp associated with the information generated by this class.
    date: datetime = None
    # The status of the build:
    #     new, building, ready, submitted, complete, failed, delayed
    status: str = "new"
    # payload, here, is the projectID, useful for finding output
    payload: str = ""
    # For convenience:
    # The sequence that inspired this build is contained here.
    # This should be the official version that is used to generate the primary
    # key for database searches.  See seqID.
    pUUID: str = ""
    entity_id: str = ""
    service_id: str = ""
    incomingSequence: str = ""
    indexOrderedSequence: str = ""
    # For convenience:
    # The seqID is a UUID hash of the sequence.  The seqID is used as a primary
    # key for retrieving information about the sequence from databases.
    seqID: str = ""
    # conformerID contains a terse label representing the structural details
    #    of this conformer.  It might encode rotamer names, ring pucker,
    #    protonation state, etc.  If there is only one conformational isomer
    #    available for this structure, it is simply 'structure'.
    conformerID: str = ""
    # conformerLabel may be either :
    #    * the same as the conformerID
    #    * a uuid made from the conformer ID if the conformerID is  > 32 char long.
    #  The conformerLabel is used to name directories and files.  The 32 character
    #  limit keeps directories from becoming difficult to read.  it also helps keep
    #  file names and paths from exceeding length limits.
    conformerLabel: str = ""
    #  The sequenceConformation is a more human-readable description of the
    #  structural details of the conformer.  It contains the same information as
    #  the conformerID.
    #  This structure has been considered, but it might not give us the needed
    #  flexibility:  sequenceConformation : List[RotamerConformation] = None
    #  Oliver says this:
    #      Would be nice to just directly use the gmml level class like this:
    #      gmmlConformerInfo : gmml.single_rotamer_info_vector = None
    sequenceConformation: List = []
    #  When there are multiple structures, one is chosen for the default.
    isDefaultStructure: bool = False
    isNewBuild: bool = False
    # The following are locations needed by builders and/or retrievers.
    structureDirectoryName: str = ""
    filesystem_path: str = ""
    host_url_base_path: str = ""
    conformer_path: str = ""
    absolute_conformer_path: str = ""
    downloadUrlPath: str = ""
    # The following are options relevant to how the structure is built.
#    simulationPhase : str = "gas-phase"  ## also solvent model, e.g., TIP3P, TIP5P
#    solvationShape : str = None   ## Solvated requests might specify a shape.
#    addIons : str = "default" ## Is there a benefit for this to be a String? Boolean?
#    energy : str = None ## kcal/mol
    # TODO: This needs to be a class. Schedule design with Lachele.
    forceField: str = 'See Build Directory Files'

    def __init__(self, **data: Any):
        super().__init__(**data)

        log.debug(
            "These are the values at initialization of Single3DStructureBuildDetails")
        log.debug("payload(projectID): " + self.payload)
        log.debug("incomingSequence: " + self.incomingSequence)
        log.debug("indexOrderedSequence: " + self.indexOrderedSequence)
        log.debug("seqID: " + self.seqID)
        log.debug("conformerID: " + self.conformerID)
        log.debug("conformerLabel: " + self.conformerLabel)
        log.debug("conformerPath: " + self.conformer_path)
        log.debug("downloadUrlPath: " + self.downloadUrlPath)

    # Setters that contain logic should be built another way

    # theBuildDir is usually "New_Builds" or "Existing_Builds" unlesss it is the general case
    def setAbsoluteConformerPath(self, theBuildDir: str):
        self.absolute_conformer_path = join(
            self.filesystem_path,
            self.entity_id,
            self.service_id,
            'Builds',
            self.pUUID,
            theBuildDir,
            self.structureDirectoryName)

    def setConformerPath(self):
        self.conformer_path = join(
            self.filesystem_path,
            self.entity_id,
            self.service_id,
            'Builds',
            self.pUUID,
            'Requested_Builds',
            self.structureDirectoryName)

    def setSeqId(self, theSeqID: str = None):  # does this need a noclobber option?
        if theSeqID is not None:
            self.seqID = theSeqID
            return
        if self.indexOrderedSequence == "":
            error = "Cannot derive a seqID from an empty indexOrderedSequence string"
            log.error(error)
            raise error
        self.seqID = projectUtils.getSeqIdForSequence(
            self.indexOrderedSequence)


# @class StructureBuildInfo
#    @brief An object to represent the data previously held in the Structure_Mapping_Table.
#    @detail This object holds the data that describes a series of ways that this single structure
#            has been built. Each variation of a rotamer or from gas-phase to solvated, etc...
#            represents a different build state, and each gets a record in this object.
#            This object can be used to track a request, and a copy of it could be used to track
#            the progress of that requested series of jobs.


class StructureBuildInfo(BaseModel):
    # Useful to know what this all applies to.
    incomingSequence: str = ""
    indexOrderedSequence: str = ""
    seqID: str = ""  # UUID based on indexOrderedSequence
    # A build state is a descriptive object that can be used to request a pdb file
    #    of a sequence in a specific pose, with various other settings as well.
    individualBuildDetails: List[Single3DStructureBuildDetails] = []
    buildStrategyID: str = 'buildStrategyID1'

    def setSeqId(self):
        if self.indexOrderedSequence == "":
            error = "Cannot derive a seqID from an empty indexOrderedSequence string"
            log.error(error)
            raise error
        self.seqID = projectUtils.getSeqIdForSequence(
            self.indexOrderedSequence)


def generateSchema():
    print(StructureBuildInfo.schema_json(indent=2))


if __name__ == "__main__":
    generateSchema()
