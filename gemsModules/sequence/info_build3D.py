#!/usr/bin/env python3
from typing import List, Any 
from os.path import join
from datetime import datetime
from pydantic import BaseModel
from gemsModules.common.loggingConfig import *
import gemsModules.project.projectUtilPydantic as projectUtils
import traceback


if loggers.get(__name__):
    pass
else:
    log = createLogger(__name__)




class Single3DStructureBuildDetails(BaseModel):
    ##################################
    # This class was built by merging two older classes.  Therefore, some names
    # might appear to be duplicates.  They might even be duplicates.  There
    # is no time now for this sort of cleaning now.  Please feel free to do so.
    ##################################
    # The timestamp associated with the information generated by this class.
    date: datetime = None
    # The status of the build:
    #     new, building, ready, submitted, complete, failed, delayed
    status: str = "new"
    # payload, here, is the projectID, useful for finding output
    payload: str = ""
    # For convenience:
    # The sequence that inspired this build is contained here.
    # This should be the official version that is used to generate the primary
    # key for database searches.  See seqID.
    pUUID: str = ""
    entity_id: str = ""
    service_id: str = ""
    incomingSequence: str = ""
    indexOrderedSequence: str = ""
    # For convenience:
    # The seqID is a UUID hash of the sequence.  The seqID is used as a primary
    # key for retrieving information about the sequence from databases.
    seqID: str = ""
    # conformerID contains a terse label representing the structural details
    #    of this conformer.  It might encode rotamer names, ring pucker,
    #    protonation state, etc.  If there is only one conformational isomer
    #    available for this structure, it is simply 'structure'.
    conformerID: str = ""
    # conformerLabel may be either :
    #    * the same as the conformerID
    #    * a uuid made from the conformer ID if the conformerID is  > 32 char long.
    #  The conformerLabel is used to name directories and files.  The 32 character
    #  limit keeps directories from becoming difficult to read.  it also helps keep
    #  file names and paths from exceeding length limits.
    conformerLabel: str = ""
    #  The sequenceConformation is a more human-readable description of the
    #  structural details of the conformer.  It contains the same information as
    #  the conformerID.
    #  This structure has been considered, but it might not give us the needed
    #  flexibility:  sequenceConformation : List[RotamerConformation] = None
    #  Oliver says this:
    #      Would be nice to just directly use the gmml level class like this:
    #      gmmlConformerInfo : gmml.single_rotamer_info_vector = None
    sequenceConformation: List = []
    #  When there are multiple structures, one is chosen for the default.
    isDefaultStructure: bool = False
    isNewBuild: bool = False
    # The following are locations needed by builders and/or retrievers.
    structureDirectoryName: str = ""
    filesystem_path: str = ""
    host_url_base_path: str = ""
    conformer_path: str = ""
    absolute_conformer_path: str = ""
    downloadUrlPath: str = ""
    # The following are options relevant to how the structure is built.
#    simulationPhase : str = "gas-phase"  ## also solvent model, e.g., TIP3P, TIP5P
#    solvationShape : str = None   ## Solvated requests might specify a shape.
#    addIons : str = "default" ## Is there a benefit for this to be a String? Boolean?
#    energy : str = None ## kcal/mol
    # TODO: This needs to be a class. Schedule design with Lachele.
    forceField: str = 'See Build Directory Files'

    def __init__(self, **data: Any):
        super().__init__(**data)

        log.debug(
            "These are the values at initialization of Single3DStructureBuildDetails")
        log.debug("payload(projectID): " + self.payload)
        log.debug("incomingSequence: " + self.incomingSequence)
        log.debug("indexOrderedSequence: " + self.indexOrderedSequence)
        log.debug("seqID: " + self.seqID)
        log.debug("conformerID: " + self.conformerID)
        log.debug("conformerLabel: " + self.conformerLabel)
        log.debug("conformerPath: " + self.conformer_path)
        log.debug("downloadUrlPath: " + self.downloadUrlPath)

    # Plain setters because logic elsewhere should determine them

    def setIsNewBuild(self, IsNewBuild: bool):
        self.isNewBuild = IsNewBuild

    def setEntityId(self, theEntityId: str):
        self.entity_id = theEntityId

    def setServiceId(self, theServiceId: str):
        self.service_id = theServiceId

    def setPuuid(self, thePuuid: str):
        self.pUUID = thePuuid

    def setFilesystemPath(self, thePath: str):
        self.filesystem_path = thePath

    def setHostUrlBasePath(self, thePath: str):
        self.host_url_base_path = thePath

    def setConformerLabel(self, theLabel: str):
        self.conformerLabel = theLabel

    def setConformerId(self, theId: str):
        self.conformerID = theId

    def setStructureDirectoryName(self, theStructureDirectoryName: str):
        self.structureDirectoryName = theStructureDirectoryName

    def setIndexOrderedSequence(self, theIndexOrderedSequence: str):
        self.indexOrderedSequence = theIndexOrderedSequence

    def setDownloadUrlPath(self, theDownloadUrlPath: str):
        self.downloadUrlPath = theDownloadUrlPath

    # Setters that contain logic

    # theBuildDir is usually "New_Builds" or "Existing_Builds" unlesss it is the general case
    def setAbsoluteConformerPath(self, theBuildDir: str):
        self.absolute_conformer_path = join(
            self.filesystem_path,
            self.entity_id,
            self.service_id,
            'Builds',
            self.pUUID,
            theBuildDir,
            self.structureDirectoryName)

    def setConformerPath(self):
        self.conformer_path = join(
            self.filesystem_path,
            self.entity_id,
            self.service_id,
            'Builds',
            self.pUUID,
            'Requested_Builds',
            self.structureDirectoryName)

    def setSeqId(self, theSeqID: str = None):  # does this need a noclobber option?
        if theSeqID is not None:
            self.seqID = theSeqID
            return
        if self.indexOrderedSequence == "":
            error = "Cannot derive a seqID from an empty indexOrderedSequence string"
            log.error(error)
            raise error
        self.seqID = projectUtils.getSeqIdForSequence(
            self.indexOrderedSequence)

    # All the getters are plain so far

    def getEntityId(self):
        return self.entity_id

    def getServiceId(self):
        return self.service_id

    def getConformerPath(self):
        return self.conformer_path

    def getAbsoluteConformerPath(self):
        return self.absolute_conformer_path

    def getDownloadUrlPath(self):
        return self.downloadUrlPath

    def getSeqId(self):
        return self.seqID

    def getFilesystemPath(self):
        return self.filesystem_path

    def getHostUrlBasePath(self):
        return self.host_url_base_path

    def getConformerLabel(self):
        return self.conformerLabel

    def getConformerID(self):
        return self.conformerID

    def getStructureDirectoryName(self):
        return self.structureDirectoryName

    def getIndexOrderedSequence(self):
        return self.indexOrderedSequence

# @class StructureBuildInfo
#    @brief An object to represent the data previously held in the Structure_Mapping_Table.
#    @detail This object holds the data that describes a series of ways that this single structure
#            has been built. Each variation of a rotamer or from gas-phase to solvated, etc...
#            represents a different build state, and each gets a record in this object.
#            This object can be used to track a request, and a copy of it could be used to track
#            the progress of that requested series of jobs.


class StructureBuildInfo(BaseModel):
    # Useful to know what this all applies to.
    incomingSequence: str = ""
    indexOrderedSequence: str = ""
    seqID: str = ""  # UUID based on indexOrderedSequence
    # A build state is a descriptive object that can be used to request a pdb file
    #    of a sequence in a specific pose, with various other settings as well.
    individualBuildDetails: List[Single3DStructureBuildDetails] = []
    buildStrategyID: str = 'buildStrategyID1'

    def setIncomingSequence(self, inputSequence):
        self.incomingSequence = inputSequence

    def setIndexOrderedSequence(self, inputSequence):
        self.indexOrderedSequence = inputSequence

    def setBuildStrategyID(self, newBuildStrategyID):
        self.buildStrategyID = newBuildStrategyID

    def setSeqId(self):
        if self.indexOrderedSequence == "":
            error = "Cannot derive a seqID from an empty indexOrderedSequence string"
            log.error(error)
            raise error
        self.seqID = projectUtils.getSeqIdForSequence(
            self.indexOrderedSequence)

    def getIndividualBuildDetails(self):
        return self.individualBuildDetails

    def getBuildStrategyID(self):
        return self.buildStrategyID

    def getSequence(self):
        return self.sequence

    def getSeqId(self):
        return self.seqID



def generateSchema():
    print(StructureBuildInfo.schema_json(indent=2))


if __name__ == "__main__":
    generateSchema()
